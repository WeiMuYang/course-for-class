# 07-2 上课计划  
---

## 1 回忆上节课内容  
### 1.1 杂事  
- 雪梨作业任务4（不要忘了提交）      
- 重修点名及参加小测名单     

### 1.2 上节课总结    
[Class07-1](../course-summary/Class07-1-20191015.txt)      
```
## 07-1-20191015                      
1. 栈的应用：行编辑程序、迷宫求解、表达式求值、地图四染色        （了解）    
2. 队列的定义及基本概念             （理解）    
3. 双端队列                        （理解）   
4. 链队列的结构                    （掌握、实现）   
5. 链队列基本操作：初始化、销毁、插入（入队）、删除（出队）   （掌握、实现）      

注意：对于栈的应用，有兴趣的学生可以写一写，写完了发QQ离线文件。         
```
### 1.3 学生的问题      
1. 程序调试     
2. 下标和指针作为top的区别  
3. 任务4-3，在哪给字符串开辟空间    


---


## 2 栈和队列              
### 2.1 递归与栈（没讲）      
> [算法3.5-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/14-Algorithm-3.5-(指针).c)            
- 汉诺塔是做什么？      
>>递归具备条件：
>>1. 递归结束条件    
>>2. 相邻项之间存在递推关系      
- 将一个大问题化简成若干个小问题，这些小问题和大问题是一种问题，在化简成小问题过程中，逐渐向终止条件靠拢，最终结束    

>算法思路：      
- 在移动圆盘过程中，总会是：       
>> 1. 将x上的`1~n-1`移动到y，z作为辅助     
>> 2. 然后将n由x移动到z      
>> 3. 将y上的`1~n-1`，移动到z，x作为辅助        

>函数作用：    
- `hanoi(int n, char x, char y, char z)` 将x上编号为1~n的圆盘移动至z，y作为辅助塔        
- `move(char x, int n, char z)`将编号为n的圆盘从x移动到z     

>递归和栈如何转换，解释清楚     

---

## 3 队列    
- [动态-链式-引用版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/15-Algorithm-queue-(动态-链式-引用).cpp)    
- [动态-链式-指针版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/16-Algorithm-queue-(动态-链式-指针).c)        
- [动态-顺序-引用版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/17-Algorithm-queue-(动态-顺序-引用).cpp)    
- [动态-顺序-指针版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/18-Algorithm-queue-(动态-顺序-指针).c)          

### 3.1 链队列    
- 上课写找学生写代码，链队列的基本操作     

### 3.2 循环队列    
#### 3.2.1 循环队列的定义  
- 定义   
- 地址连续，设置队头和队尾指针（下标）      
- 入队，尾指针增 1 ，出队，头指针增 1     
#### 3.2.2 “假溢出”问题    
- 队列的存储空间未满，却发生了溢出       
>解决方法：     
1. 平移元素：把元素平移到队列的首部。效率低。     
2. 将新元素插入到第一个位置上，构成循环队列， 入队和出队仍按“先进先出”的原则进行。    


#### 3.2.2 循环加一      
>循环队列的三种状态   
1. 中间状态，队列中元素个数可以通过`front`和`rear`求元素个数，但是 `front`和`rear`大小不定    
2. 仅凭 front = rear 不能判定队列是空还是满 ?    
>>- 另设一个布尔变量以区别队列的空和满(使用一个计数器记录队列中元素的总数。)；   
>>- 少用一个元素的空间，约定入队前测试尾指针在循环意义下加 1 后是否等于头指针，若相等则认为队满；   

>循环意义下的加一:       
```C
if (rear + 1 >= MAXQSIZE)
    rear = 0;
else
    rear++; 
//等价于： rear = (rear + 1)% MAXQSIZE  
```
- 分支预测器猜测条件表达式的两路分支中哪一路最可能发生，然后推测执行这一路的指令，来避免流水线停顿造成的时间浪费。如果后来发现分支预测错误，那么流水线中推测执行的那些中间结果全部放弃，重新获取正确的分支路线上的指令开始执行，这招致了程序执行的延迟。      
- 求模运算比分支运算效率更高     



### 3.3 循环队列的实现     
#### 3.3.1 循环队列的基本结构   
```C
typedef struct
{
	QElemType *base;	//初始化的动态分配存储空间
	int front;			//头指针，若队列不空，指向队列头元素
	int rear;			//若队列不空，指向队列元素的下一个元素
}SqQueue;
```
- `front`和`rear`虽然是下标但是起到的作用是指针作用      
- 这种结构虽然是动态顺序存储，但是却不能追加空间        

#### 3.3.2 循环队列的初始化`InitQueue`函数      
- 给`base`、`front`和`rear`赋值的过程    
- 如果申请堆区空间失败的话，退出      

#### 3.2.3 循环队列的求长度`QueueLength`函数    
>由于经过循环加一， `front`和`rear`大小不定，因此`rear`-`front`:     
1. 若为正数，则即为所求；   
2. 若为负数，则加上数组容量      

合并以上两种情况：`(Q.rear - Q.front + MAXQSIZE) % MAXQSIZE` 

#### 3.3.4 循环队列的插入`EnQueue`函数      
1. 先加一看下是否队列满了，如果满了就不能插入，不能追加空间      
2. 插入e     
3. 尾指针循环加一     

#### 3.3.5 循环队列的删除`DeQueue`函数    
1. 先看队列是否为空    
2. 取出队头元素给e     
3. 队头指针循环加一    



---

## 4 课下作业           
- 雪梨作业    
- 下节课写循环队列代码    












