# 07-1 上课计划  
---

## 1 回忆上节课内容  
### 1.1 杂事  
- 雪梨作业（本周发布链表的作业）      
- 许一凡复习资料         
- 雪梨作业不规范问题，早晚吃亏（重点强调）        
- 重修点名及参加小测名单     
- 小测时间：讲完串一次（第9周）、讲完树（第13周）一次         
- 抄袭已经有几个人判0分了，不同班级的雷同     
- 雪梨任务4已经发布，提前去做     

### 1.2 上节课总结    
[Class06-2](../course-summary/Class06-2-20191010.txt)      
```
## 06-2-20191010                      
1. 动态顺序栈的基本操作及实现       （掌握、实现）     
2. 静态顺序栈的基本操作及实现       （了解）    
3. 动态链栈的基本操作及实现，对比单链表头插头删理解           （理解）     
4. 数制转换                                     （了解）   
5. 括号匹配                                     （理解）     
```
### 1.3 学生的问题      
1. 程序调试     
2. 雪梨作业有学生问题    

   

---


## 2 栈和队列              
### 2.1 栈的表示和实现      
#### 2.1.1 动态顺序存储      
- [动态-顺序-引用版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/01-Algorithm-stack-(动态-顺序-引用).cpp)    
- [动态-顺序-指针版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/02-Algorithm-stack-(动态-顺序-指针).c)        
1. 动态顺序存储和静态顺序存储栈的结构      
2. 基本操作中加工型操作和引用型操作      
3. `InitStack`初始化操作：修改三个属性成员，`top`既可以指向栈顶元素下一个位置，也可以指向栈顶元素       
4. `GetTop`获取栈顶元素，栈顶指针不可修改       
5. `Push`压栈（插入）`*S.top++ = e;`虽然后自增优先级高于寻址，但是它是语句执行完成后再自增，讲的时候可以先将 `S.top++`括起来`(S.top++)`      
6. `Pop`出栈（删除）`e = *--S.top`     

### 2.2 栈的应用       
#### 2.2.1 括号匹配（简单回忆）     
> [算法3.2-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/10-Algorithm-matchBracket-(指针).c)            
括号匹配的过程中，可能出现以下三种错误：         
1. `{[(q))`到来的是“不速之客” (右括号多)      
2. `{[(q]` 盼来的右括号不是所“期待”的 (左右括号不匹配)     
3. `{[(q)]`到结束也未盼来所“期待”的括号 (左括号多)     

#### 2.2.2 行编辑程序     
> [算法3.2-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/11-Algorithm-3.2-(指针).c)            
- 接收字符直接存入数据区，纠错差，一般放入缓冲区，通过特殊字符实现退格`#`或者退行`@`   
- 将字符串每行放入栈中，然后通过接收的`#`和`@`符号实现Pop或者Clear操作    
- 如果非`#`和`@`实现入栈Push操作         
- 一行放到一个栈中，因此遇到结束或者遇到回车输出（传送）一次数据然后清空栈    

```C
// 测试示例
whli##ilr#e(s#*s)
    outcha@putchar(*s=#++);
```

>算法步骤：      
1. 初始化一个栈    
2. 接收第一个字符    
3. while循环是否是文本结束，若不是则进入判断文本内容，否则销毁栈      
4. while循环判断文本内容是否是行结束或者文本结束，若不是开关语句进行行编辑，并继续接收字符，若是行结束打印栈中数据，清空栈，继续接受下一行；若是文本结束，打印栈中数据，清空栈，调出循环    


#### 2.2.3 迷宫求解     
> [算法3.3-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/12-Algorithm-3.3-(指针).c)            
- 如何将迷宫存入计算机中：通过0 和 1存储，0表示通路，1表示不通        
- 设计存储结构，坐标位置(X, Y)    
- 如何记录走过的位置：位置和方向，但是为了更好的记录走了多少步，每步次序是什么可以在路径上带上“序号”    
- 在获取新位置后，从该位置的东边开始找是否有可以走的格子：依次东南西北找       
- 不能通过的情况：①本来就不通    ②这个可以通过，但是它的四个方向不能走通，这种情况需要走过做个标记，下次不再走        
```C
typedef struct{
    int ord;		//通道块在路径上的“序号”(如果有栈存在，该项可以有可以没有，
    			    //如果这个栈后期销毁了，那么这个就必须有)
    PosType seat;	 //通道块在迷宫中的“坐标位置”
    int di;			//从此通道块走向下一通道块的“方向”
				   //1：东    
}SElemType,ElemType;
```

>算法步骤：      
1. 初始化一个栈，用来记录**尝试**走的位置，想走就入栈，不能走就出栈，记录起点       
2. 若位置可以通过，记录这个位置，入栈，找这个位置的东邻，作为下一个探索的位置     
3. 若该位置4个方向都探索完毕不能通过，栈也不为空，后退一个位置（出栈），记录下来这个位置不能通过         
4. 后退一步，换一个新方向继续探索，将这个新的位置设置成当前位置继续判断        
5. 如果最后栈为空，说明后退到起始位置都不能走通，那么该迷宫不能走通        

#### 2.2.4 表达式求值   
> [算法3.4-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/13-Algorithm-3.4-(指针).c)            
- 表达式求值的一般规则：先乘除后加减，从左到右，先括号内后括号外           
- 乘除大于加减，相同优先级左边大于右边      
- 如何将优先级规则存入计算机    
- 创建两个栈一个存放操作数，一个存放运算符      
- 因为只声明一个栈，那么这个这个栈的类型：既可以存放操作数，也可以存放运算符，我们如果使用int作为基本元素类型的话，那么接收的元素值如果和ASCII码相同的话就会出现问题   

>算法步骤：      
>1. 初始化两个栈，一个存放操作数，一个存放运算符       
2. 栈顶运算符作为$\theta_1$和输入运算符作为$\theta_2$比较：
     >如果$\theta_1 < \theta_2$的话，入栈；    
     如果$\theta_1 > \theta_2$的话，出栈，出栈时，选出两个操作数，这两个操作数先出来的是右操作数 b 然后是左操作   数a；   
     如果$\theta_1 == \theta_2$的话 ，只出栈    

### 2.3 递归与栈（先不讲）    
> [算法3.5-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/14-Algorithm-3.5-(指针).c)            
-    

>算法步骤：      
1. 初始化两个栈，一个存放操作数，一个存放运算符       
2. 栈顶运
3. 算符和输入 运

    

## 3 队列    
- [动态-链式-引用版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/15-Algorithm-queue-(动态-链式-引用).cpp)    
- [动态-链式-指针版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/16-Algorithm-queue-(动态-链式-指针).c)        
- [动态-顺序-引用版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/17-Algorithm-queue-(动态-顺序-引用).cpp)    
- [动态-顺序-指针版](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/3-栈和队列/18-Algorithm-queue-(动态-顺序-指针).c)          

1. 动态顺序存储和静态顺序存储栈的结构      
2. 基本操作中加工型操作和引用型操作      
### 3.1 队列的定义    
1. 队列的基本概念     
2. 双端队列不是队列      

### 3.2 链队列——队列的链式表示和实现    
1. 头指针、尾指针作用    
2. 链队列为空的情况    
#### 3.2.1 链队列的结构    
```C
//---单链队列——队列的链式存储结构(带头结点)---//
typedef struct QNode{
	QElemType data;
	struct QNode *next;
}QNode, *QueuePtr;
typedef struct{
	QueuePtr front;	//队头指针
	QueuePtr rear;	//队尾指针
}LinkQueue;
```
#### 3.2.2 链队列的初始化`InitQueue`函数    
>注意：    
- 给队列中属性成员头指针和尾指针赋值的过程    
- 新建一个头结点，指针域置为`NULL`     
- 如果新结点空间申请失败，则退出    

#### 3.2.3 链队列的销毁`DestroyQueue`函数    
>注意：    
- 释放队列中，所有结点   
- `front`作为移动指针，一次从头结点开始向后释放    
- `rear`指向`front`所指结点的后继    

>步骤：   
1. 若`front`指针不为空，重复以下3步    
2. `rear`指针指向`front`所指结点的后继     
3. 释放`front`所指结点    
4. `front`指针后移        


#### 3.2.4 链队列的入队`EnQueue`函数    
>注意：    
-  插入`e`作为新的队尾元素       
-  指针`p`最后被两次赋值     
- 入队在队尾插入，只考虑队尾指针`rear`，而与队头指针`front`无关     

>步骤：   
1. 先`p`指向新建的结点，若申请失败则退出    
2. 将新结点的指针域为`NULL`和数据域`e`        
3. 修改队列中最后结点指针域为`p`   
4. 将队列的队尾指针`rear`改为`p`    

#### 3.2.5 链队列的出队`DeQueue`函数    
>注意：    
-  删除队头元素       
-  判断队列是否为空    
-  需要判断删除完成后队列是否为空，决定是否需要移动队尾指针         
- 释放删除的结点        

>步骤：   
1. 判断队列是否为空       
2. `p`指向要删除的结点，取出删除结点的数据域        
3. 修改头结点的指针域为：`p->next`    
4. 若删除的结点是唯一的一个结点`Q.rear == p`，那么修改让队尾指针`rear`也指向头结点       
5. 释放`p`指向结点       


## 4 课下作业    
- 由于雪梨作业比较多，对于链队列的实现，没让大家提交；    
- 下节课利用上课时间写链队列的基本操作            










