# 15-1 上课计划     

---


## 1 回忆上节课内容  
### 1.1 杂事  
1. 小测已经结束   
2. 期末复习准备，期末考试试卷题型   
3. 数据结构大作业        
4. 需不需要讲下试卷，及最短路径的实现     


### 1.2 上节课总结    
[Class14-2](../course-summary/Class14-2-20191205.txt)      
```
## 14-2-20191205                                    
1. 关键路径的求法                   （理解、掌握）        
2. 单源点最短路径——迪杰斯特拉算法     （理解、掌握、实现）   
3. 多源点最短路径——弗洛伊德算法       （了解）     
4. 查找的基本概念                   （理解）    
```

---

## 2 查找表    
查找表的结构
```C
#define KeyType int
#define InfoType char
typedef struct{
	KeyType key;	//数据元素中查找的关键字
	InfoType* info;	//数据元素中的其他信息
}ElemType;

typedef struct{
	ElemType *elem;	//数据元素存储空间基址，建表时按实际长度分配，0号单元留空
	int length;		//表长度
}SSTable;
```
### 2.1 静态查找表   
#### 2.1.1 顺序查找    
[算法9.1](../../05_data-structure-code/8-查找/01-Algorithm-9.1-Search_Seq-引用.cpp)    
>顺序查找：从表的一端开始，逐个进行记录的关键字和给定值的比较。    
1. 监视哨:elem[0]：哨兵作用        
2. 从后向前进行查找   
2. 当 `ST.length >= 1000`时，此改进能使进行一次查找所需的平均时间几乎减少一半。  

>算法步骤：   
1. 将查找的key值放入，顺序表中0号空间    
2. i从ST.length开始循环，若第i个元素的key值不等于要查找的key值，i自减；    
3. 循环结束，返回i值    

>效率分析：   
1. **平均查找长度（ASL）**为确定记录在查找表中的位置，需要和给定值进行**比较的记录的个数的期望值**称为算法在查找成功时的平均查找长度。 衡量查找算法好坏的依据。    
2. **查找成功时**，查找第i个元素，需要比较`n+1-i`，每个记录查找概率相等：`p = 1/n`,则`ASL（SS） = (n+1)/2`         
3. **查找不成功时**，查找成功和不成功的概率均为1/2，那么查找不成功需要比较`n+1`次，那么，`ASL（SS） = (n+1)/2 + (n+1)/4 = 3(n+1)/4`   

#### 2.1.2 折半查找    
[算法9.2](../../05_data-structure-code/8-查找/03-Algorithm-9.2-Search_Bin-引用.cpp)    
>折半查找：    
1. **有序表**表示静态查找表    
2. 依次缩小查找区间，直到找到了，或者`high < low`则查找结束    

>算法步骤：    
1. 先设置查找区间     
2. 若`low <= high`循环以下三步：
3. 求查找区间中间元素位置mid   
4. 若key == ST.elem[mid].key，返回mid    
5. 若key < ST.elem[mid].key，high为mid - 1   
6. 若key > ST.elem[mid].key，low = mid + 1    
7. 返回0。     

>效率分析：  
1. **查找成功时**，比较次数是路径上的结点数，比较次数 = 结点的层数    
2. 比较次数 ≤ 树的深度 =$ \lfloor log_2n  \rfloor +1 $    
3. **查找不成功时**，比较次数 = 路径上的内部结点数      
4. **查找成功时**，$ASL_bs = log_2(n + 1) -1  $   
5. 折半查找优点：效率比顺序查找高。   
6. 折半查找缺点：只适用于有序表，且限于顺序存储结构。   

#### 2.1.3 索引查找（分块查找）   
>索引查找：    
1. 将表分成几块，且表或者有序，或者分块有序；     
2. 若 i  < j，则第 j 块中所有记录的关键字均大于第i块中的最大关键字    
3. 建立“索引表”（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）。  
>算法步骤：   
1. 先确定待查记录所在块（顺序或折半查找）    
2. 在块内查找（顺序查找）。     

>效率分析：  
1. 在索引表中查找所在块的平均查找长度+在块中查找元素的平均查找长度   
2. 若将长度为 n 的表均分成 b 块，每块含 s 个记录$ (b =  \lceil  n/s \rceil) $ ； 并设表中每个记录的查找概率相等，则每块查找的概率为 1/b，块中每个记录的查找概率为 1/s。    
3. **顺序查找**:  $ ASL_{bs} = (b+1)/2 + (s+1)/2 $     
4. **折半+顺序**: $ log_2(b+1) -1 + (s+1)/2 $   



### 2.2 动态查找表    
[算法9.5-9.8](../../05_data-structure-code/8-查找/07-Algorithm-9.5-9.8-SearchBST-引用.cpp)     
>二叉排序树或者是一颗空树；或者是具有下列性质的二叉树：   
1. 若它的左子树不空，则左子树上的所有结点的值，均小于它的根结点的值；    
2. 若它的右子树不空，则右子树上所有结点均大于它的根结点的值；   
3. 它的左右子树也分别为二叉排序树      


>查找算法-9.5(a)：   
若二叉排序树为空，则查找不成功；否则    
1. 若给定值等于根结点的关键字，则查找成功；    
2. 若给定值小于根结点的关键字，则继续在左子树上进行查找；    
3. 若给定值大于根结点的关键字，则继续在右子树上进行查找。    

>查找算法-9.5(b)：   
1. 若二叉排序树为空，`p = f`，查找不成功     
2. 若`key == T-> data.key` ，`p = T`，查找成功     
3. 若`key < T-> data.key` ，在T的左子树进行查找    
4. 若`key > T-> data.key` ，在T的右子树进行查找     

>插入算法：     
1. 若二叉排序树为空树，则新插入的结点为根结点；     
2. 若二叉排序树非空，则新插入的结点必为一个新的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。    

>查找步骤：   
1. 先进行查找，若查找不成功，进行下面操作：   
2. 创建新结点，数据域为`e`,左右孩子域为空    
3. 若p为空，则说明为空树，则只需让T指向新结点    
4. 若`e.key < p -> data.key`，则将s指向结点插入左孩子    
5. 若`e.key > p -> data.key`，则将s指向结点插入右孩子    




>二叉排序树的创建：    
- 从空树出发，经过一系列的查找、插入操作 之后，可生成一棵二叉排序树。    
- 中序遍历二叉排序树可得到一个关键字的有序序列。     
- 一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。    
- 插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录。    
- 二叉排序树既有类似于折半查找的特性，又采用了链表作存储结构。     

>二叉排序树的删除:     
**要求：在删除某个结点之后，仍然保持二叉排序树的特性。 **    
删除二叉排序树中的 \*p 结点，分三种情况讨论：  
1. \*p 为叶子结点。因删除叶子结点不破坏树的结构，故只需修改 \*p 双亲 \*f 的指针：f -> lchild=NULL  或 f->rchild=NULL    
2. \*p 只有左子树或右子树：  \*p 只有左子树，用  \*p 的左孩子代替  \*p； \*p 只有右子树，用 \*p 的右孩子代替 \*p；    
3. \*p 左、右子树均非空    

>二叉排序树的查找分析:    
1. 二叉排序树上查找其关键字等于给定值的结点的过程其实就是走了一条从根到该结点的路径。   
2. 比较的关键字次数 = 此结点所在层次数 = 最多的比较次数 = 树的深度     
3. 含有 n 个结点的二叉排序树的平均查找长度和树的形态有关    
4. n个结点的二叉判断树是唯一的，因此，其平均查处长度也是定值    
5. **最好情况： ** $   ASL=log 2(n + 1) – 1 $     
6. **最坏情况： ** $   ASL = (n + 1) / 2    $     




### 2.3 平衡二叉树      
**性质：**   
1. 左、右子树是平衡二叉树；  
2. 所有结点的左、右子树深度之差的绝对值≤ 1。    

>为了方便起见，给每个结点附加一个数字 = 该结点左子树与右子树的深度差。这个数字称为结点的平衡因子。这样，可以得到 AVL 树的其它性质（可以证明）：     
1. 任一结点的平衡因子只能取：-1、0 或 1；如果树中任意一个结点的平衡因子的绝对值大于 1，则这棵二叉树就失去平衡。    
2. 对于一棵有 n 个结点的 AVL 树，其深度和 log n 同数量级，ASL 也和 log n 同数量级。因此，在平衡二叉树上查找时间复杂度为O(log n)。    

>平衡旋转：    
1. LL 平衡旋转    
2. RR 平衡旋转   
3. LR 平衡旋转   
4. RL 平衡旋转   


### 2.4 B-树   
>一棵 m 阶的 B- 树，或为空树或为满足下列特性的 m 叉树：    
1. 树中每个结点至多有 m 棵子树；    
2. 若根结点不是叶子结点，则至少有两棵子树；    
3. 除根之外的所有非终端结点至少有$  \lceil  m/2 \rceil  $ 棵子树；    
4. 所有的非终端结点的结构为：（n, A0, K1, A1, K2, A2, …, Kn, An） 其中，Ki ( i = 1, …, n ) 为按升序排列的关键字； Ai  (i = 0, …, n) 为指向子树 根结点的指针，且 Ai-1 所指子树中所有结点的关键字均小于 ki，An 所指子树中所有结点的关键字均大于 kn，n ( 对于根结点 1≤n≤m – 1,  对于其它结点$ \lceil m/2 \rceil – 1≤ n ≤ m – 1) $ 为关键字的个数（或 n +1 为子树个数）。    
5. 所有叶子结点在同一个层次上，且不含有任何信息。（可 以看作是外部结点或查找失败的结点，实际上这些结点不 存在，指向这些结点的指针为空）。     



>B-树的特点：    
>>1.平衡     
-  树中所有叶子结点均不带信息且在树的同一层次上   
- 根结点或为叶子结点，或至少含有两个子树   
- 所有非叶子结点均含有n$  \lceil m/2 \rceil \le n \le m  $颗子树    

>>2.多路       
在 m 阶的 B- 树上，每个非终端结点可能含有：      
- n 个关键字 Ki（1≤i≤n）n < m    
- n 个指向记录的指针 Di（1≤i≤n）   
- n+1 个指向子树的指针 Ai（0≤i≤n）    

>>3.查找   
- 非叶子结点中的多个关键字均自小至大有序排列；    
- Ai -1 所指子树上所有关键字均小于 Ki  ；   
- Ai 所指子树上所有关键字均大于 Ki  。    



>B-树的查找：     
>1. 从根结点出发，沿指针搜索结点和在结点内进行顺序（或折半）查找两个过程交叉进行。    
>2. 若查找成功，则返回指向被查关键字所在结点的指针和关键字在结点中的位置；   
>3. 若查找不成功，则返回插入位置。    

>B-树的插入：     
1. 若该结点的关键字个数不超过m-1，则插入完成；    
>2. 否则，若该结点的关键字个数已达到m个，这与B-树定义不符，将引起结点的“分裂”。   
>>将结点中关键字分三部分：若m为偶数，则前面为等于    后面为大于   中间一个关键字     


>B-树的删除：  
>1. 删除最底层的某个非终端结点中的关键字   
>>如果被删关键字所在的节点中的关键字数目不小于$  \lceil m/2 \rceil $，则只须从该结点中删除该关键字，删除完成，否则要进行“合并”结点的操作。可以按照下列两种情况进行处理：
>>找兄弟借：兄弟结点中的最小（或最大）的关键字上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键字所在结点。      
>>兄弟借不到：在删除关键字之后，他所在结点中剩余的关键字和指针，加上双亲结点中的关键字ki一起合并到Ai所指的兄弟结点中（若没有右兄弟，则合并到左兄弟中）   

>2. 删除非最底层结点的关键字   
>>若删除非底层结点中的关键字Ki，则可以指针Ai所指子树中的最小关键字X替代Ki，这个X在最底层结点上，然后，再删除关键字X，即转为第一种情形。     



## 3 哈希表   
- 以上讨论的表示查找表的各种结构的共同特点：记录在表中的位置和它的关键字之间不存在一个确定的关系。    
- **查找过程：**给定值依次和关键字集合中各关键字进行比较。   
- 不同的表示方法和查找策略，其差别在于：1)、关键字和给定值进行比较的顺序(过程)不同。2)、比较的结果不同：顺序查找有两种可能——“=”与“≠”；其他查找有三种可能——“<”、“=”、“>”。     
- **查找的效率**取决于和给定值进行比较的关键字个数。    
- 用这类方法表示的查找表，其**平均查找长度都不为零**。   
对于频繁使用的查找表，希望  ASL = 0。    

记录的关键字与记录在表中的存储位置之间存在一种对应（函数）关系。若记录的关键字为  key，记录在表中的位置（称为哈希地址）为  f (key)，则称此函数  f (x) 为**哈希函数（散列函数）**。 根据设定的哈希函数H(key)和所选中的处理冲突的方法建立的**查找表**。其基本思想是：以记录的关键字为自变量，根据哈希函数，计算出对应的哈希地址，并在此存储该记录的内容。    
这一映像过程称为**哈希造表或散列**。    







---

## 4 课下作业        
1. 雪梨作业任务7   
2. 把第6章的PPT后面习题做一下       
3. 把Huffman编码和译码实现一下    
4. 压缩和解压缩也实现一下   

---












