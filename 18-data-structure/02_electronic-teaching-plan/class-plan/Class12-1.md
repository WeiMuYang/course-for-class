# 12-1 上课计划     
---
## 1 回忆上节课内容  
### 1.1 杂事  
1. 发布雪梨任务7    
2. 尽量写规范的程序，以免判错   
3. 平时上课多做习题   
4. 每日一题   
5. 任务5-2 Strfun函数，删除空间时未修改空间大小，扣5分    
6. 大家不要灰心 ，其实这次考试也代表不了什么，你们好好学    
7. 确实看到很多学生编码能力有所提高   

### 1.2 上节课总结    
[Class11-2](./course-summary/Class11-2-20191114.txt)      
```
## 11-2-20191114                       
1. 二叉树的性质4、性质5                           （理解、掌握）     
2. 二叉树的顺序存储和链式存储                      （理解）     
3. 二叉树的遍历：先序遍历、中序遍历、后序遍历         （理解、掌握）  
4. 由先序遍历（或者后序遍历）和中序遍历推出二叉树形态  （理解、掌握）
```
### 1.3 学生的问题        

---

## 2 二叉树  
### 2.1 遍历二叉树   
> [动态-顺序-引用](../../05_data-structure-code/6-树和二叉树/01-Algorithm-bitree-(动态-链式-引用).cpp)      
> [动态-顺序-指针](../../05_data-structure-code/6-树和二叉树/02-Algorithm-bitree-(动态-链式-指针).c)       
顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。    
- 先序遍历   
- 中序遍历   
- 后序遍历   

### 2.2 二叉树的递归遍历实现   
- 递归过程   
- 递归和栈的关系   
- 二叉树的每个结点经过次数   

### 2.3 中序遍历非递归实现   
- 栈里面存放是指向结点的指针类型   
- 每次出栈时，p指向栈顶结点   
- 先到最左下，再右移一位（出栈），继续最左下，在向右移一位（出栈）....直到栈为空   
- 栈的作用：记录我之前遍历的轨迹   
- 讲的时候先画图引入，如何中序遍历（借助前面的图片）   

>算法1步骤：   
1. 初始化一个栈，根结点入栈   
2. 若栈不空循环以下3步   
3. p指针向左走到尽头，并依次入栈       
4. 出栈，退出空指针   
5. 若栈不空，继续出栈，p指向该栈顶元素结点， 并打印，右孩子入栈   

>算法2步骤：   
1. 初始化一个栈，p指向根结点    
2. 若p不为空或者栈不为空，循环下面2步：   
3. 若p不为空，p指向结点入栈，p指针向左下移动   
4. 若p为空，栈不空，出栈，p指向栈顶元素，并打印，p指向右孩子   

### 2.4 叶子结点   
- 和先序遍历类似，先看根结点，再看左子树，再看右子树  
- 也可以用，中序遍历和后序遍历   
- 把count拿出去变成全局的，就是树的遍历，只不过把打印，改成判断是否是叶子结点而已    

>叶子结点步骤：   
若结点不为空，先看根结点是不是叶子，再看左子树，再看右子树     

### 2.5 求深度    
- 二叉树的深度就是左子树深度和右子树深度最大值加1   
- 当T为空时，深度为0，作为截止条件   
- 当T不为空时，求左子树深度和右子树深度，求其最大值加1，有是求深度问题，自己调用自己即可      
- 因为在求解过程中，不断向右子树和左子树靠拢，因此，最终趋近于T为0    

### 2.6 创建二叉树   
- 可以采用先序遍历创建，可以是中序遍历创建，也可以是后序遍历创建   
- 创建过程也是递归定义   
- 需要提前给出序列，其中空指针不能省略   


>算法步骤：
1. 先接受一个data（即可以是一个字符）   
2. 若这个data不是BLANK（空指针位置），执行下面2步：  
3. 创建新结点 ，给该结点的data域赋值，生成根结点    
4. 给该结点的左右指针域赋值，即创建左子树和右子树，递归调用即可   


## 3 线索二叉树   
> [动态-顺序-引用](../../05_data-structure-code/6-树和二叉树/03-Algorithm-bithrtree-(动态-链式-引用).cpp)      
> [动态-顺序-指针](../../05_data-structure-code/6-树和二叉树/04-Algorithm-bithrtree-(动态-链式-指针).c)    

### 3.1 线索二叉树原理       
- 线索化的意义：将非线性问题线性化，保存遍历结果，根据二叉树的一个结点就能确定前驱和后继结点     
- 如何保存可以节约空间：利用空的指针域    
- 另开辟空间的话，耗费空间太大    
- 利用空的指针域，然后另开辟空间标记，线索还是指针   
- 若指向前驱或者后继结点，则是指向线索     

>在线索树（中序）中找结点前驱的方法：   
1. 若左链是线索，则直接指示前驱；   
2. 若左链是指针，则“左孩找右”。 即：**中序前驱左孩找右**。   

>在线索树（中序）中找结点后继的方法：   
1. 若右链是线索，则直接指示后继；   
2. 若右链是指针，则“右孩找左”。 即：**中序后继右孩找左**。   

>**双向线索链表**    
1. 为了操作方便在二叉树的线索链表上也添加一个头结点     
2. 头结点的左孩子域指向二叉树根结点，右孩子域指向中序遍历最后一个结点      
3. 线索二叉树既有头结点，又有根结点   

>遍历线索二叉树的方式：    
1. 从序列中的第一个结点起，依次找后继，直至后继为空。   
2. 从序列中的最后一个结点起，依次找前驱，直至前驱为空。   

### 3.2 线索二叉树的遍历   
- 若右链是线索，则直接指示后继；   
- 若右链是指针，则“右孩找左”。 即：**中序后继右孩找左**。   

>算法步骤：    
1. p指针指向根结点   
2. 若p不等于头结点，循环以下5步：   
3. 若p指向的结点的左指针域是指针，p指针一直向左下移动，找该树的第一个结点     **找左**      
4. 通过p 打印最左下的结点的data    
5. 若p的右标志域是线索而且该线索不指向头结点，循环下面1步：**右链是线索，则直接指示后继**    
6. p向右孩子移动，打印data    
7. 若p的右标志域是指针，则p向右孩子移动     **右孩**     



### 3.3 线索二叉树的创建   
- 初始化时，将标志域置为0   
- 若结点没有左子树，则令其左指针指向它的“前驱”并将左指针类型标志改为 “1”；    
- 若结点没有右子树，则令其右指针指向它的“后继”并将右指针类型标志改为 “1”；    
- 为了获取“前驱” 的信息，需要在遍历过程中添加一个指针 pre，令其始终指向刚刚访问过的结。若指针 p 指 向当前访问的结点，则 pre 指向它的前驱。    

>算法步骤：    
1. 创建头结点，左边指向根结点，右边指向线索，初始化时，右指针回指    
2. 若树为空，则左指针也回指     
3. 若不为空，进行下面3步：
4. 头结点的左孩子指向根结点，前驱指针pre指向头结点       
5. 中序遍历线索化树T，  
6. 遍历完成后，pre指向最后一个结点，然后修改最后结点的右孩子域指向头结点，右线索域置为1   
7. 头结点的右孩子域置为pre      

>中序遍历线索化步骤：     
1. 若P不为空，则执行下面步骤：   
2. 递归调用线索化左子树    
3. 若p指向结点没有左孩子，Ltag置为1，左孩子指向前驱pre    **指向前驱**    
4. 若p指向结点的前驱结点（pre指向结点）没有右孩子，Rtag置为1，左孩子指向前驱pre    **指向后继**      




## 4 课下作业        
1. 雪梨任务8 本周已经发布    

---












