# 13-1 上课计划     
---

## 1 回忆上节课内容  
### 1.1 杂事  
1. 雪梨作业问的比较多的是：输出根结点到结点x的路径    
2. 处理雪梨作业判错的内容     
3. 补课一次，讲一下去年小测试题    
4. 课下大家多做题，下周第二次小测     
5. 第二次小测押题卷（自己准备就行）    
6. 把PPT读一遍   


### 1.2 上节课总结    
[Class12-2](../course-summary/Class11-2-20191114.txt)      
```
## 12-2-20191121                         
1. 树的存储——双亲表示法                      （理解、掌握、实现）     
2. 树的存储——孩子表示法、孩子兄弟表示法        （理解）     
3. 树和二叉树的相互转化                      （理解）    
4. 森林和二叉树的相互转化                    （了解）   
5. 树的遍历和森林的遍历                      （了解）   
```

---

## 2 哈夫曼树   
[Huffmantree-6.12](../../05_data-structure-code/6-树和二叉树/11-Algorithm-huffmantree-(动态-顺序-引用).cpp)    

- 分支结构，可以看成是判别树    
- 但是判别树的效率不同   
- 判别效率最高的树成为Huffman树   

### 3.1 基本概念   
**路径：**从树中一个结点到另一个结点之间的分支构成这两个结点 间的路径。    
**结点的路径长度：**两结点间路径上的分支数。     
**树的路径长度：**从树根到每一个结点的路径长度之和。记作：TL    
**特点：**扁扁的好，瘦长的不好 每多一层就会增加到达的开销   完全二叉树是路径长度最短的二叉树。 但是路径最短的二叉树不一定是完全二叉树。   
**权**将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。    
**结点的带权路径长度**从根结点到该结点之间的路径长度与该 结点的权的乘积。  
**树的带权路径长度**：树中所有叶子结点的带权路径长度之和。  记作：  
<center> $$ WPL = \sum_{k=1}^{n} w_kl_k $$  </center>

### 3.2 哈夫曼树的特点   
- 满二叉树不一定是哈夫曼树，因为还和权值有关   
- 哈夫曼树中权越大的叶子离根越近     
- 具有相同带权结点的哈夫曼树不惟一    

### 3.3 哈夫曼树的构造   
1. 构造森林全是根    
2. 选用两小造新树    
3. 删除两小添新人   
4. 重复 2、3 剩单根    
包含 n 个叶子结点的哈夫曼树中共有 2n – 1 个结点。    
哈夫曼树的结点的度数为 0 或 2， 没有度为 1 的结点。   

### 3.4 哈夫曼编码   
实际上就是哈夫曼树在通信上的应用。    
#### 3.4.1 编码长度最短   
```
     A[字符频度不同] --推出--> B[用短（长）编码表示频率大（小）的字符]
     B --次数多的长度短--> C[使得编码序列的总长度最小，使所需总空间量最少]
     C --得出--> D[数据的最小冗余编码问题]
```
#### 3.4.2 译码唯一性   
要求任一字符的编码都不能是另一字符编码的前缀！这种编码称为**前缀编码（其实是非前缀码）**。  
编码过程要考虑的两个问题：   
1. 数据的最想冗余编码问题   
2. 译码唯一性问题   

**我们可以采用二叉树来设计前缀编码**因为任意一个叶子结点都不可能在其它叶子结点的路径中。 
**用哈夫曼树设计总长度最短的二进制前缀编码**    

#### 3.4.3 编码与译码   
>编码步骤：   
1. 根据字符出现的频率，获取权值    
2. 根据权值，构造哈夫曼树    
3. 构造好的哈夫曼树左边写0，右边写1，得到字符对应的二进制序列  
4. 将字符用对应的二进制序列替换即可达到编码结果    

**注意：**由于哈夫曼树不唯一，因此编码结果不唯一    

>译码步骤：   
1. 先画出哈夫曼树     
2. 根据哈夫曼树，若编码是0，往左，编码是1，往右   
3. 一旦找到叶子，就从根开始重新出发    
4. 直到将整个序列走完   

### 3.5 哈夫曼树的实现    
#### 3.5.1 存储结构   
- 每个结点有权重，而不是结点的值，内部结点没有值      
- 可以找到双亲，也可以找孩子    
- 找双亲主要是为了从叶子到根逆向求取每个字符的赫夫曼编码   
- 采用类似双亲表示法，存储Huffman树    
数据结构：   
```C
typedef struct
{
    unsigned int weight;	//权重
    unsigned int parent,lchild,rchild;
}HTNode, *HuffmanTree;		//动态分配数组存储赫夫曼树
typedef char ** HuffmanCode;//动态分配数组存储赫夫曼编码表
```

#### 3.5.2 编码与译码的实现   
- 结点个数，决定了存储huffman树的动态数组长度    
- 我只需要知道权重就行了，没具体里面对应的值，可以用一个数组对应起来    

>编码步骤：   
1. 根据n求出结点个数，然后申请空间，0号空间不用    
2. 通过for循环初始化顺序表 ，先将权重对应填进去，没有权重的填0  **构造森林全是根**   
3. 建树：i从[n+1,m]依次选取，前面结点中，parent为0，且权值最小的两个结点，构造出双亲结点，放到下标是i的位置 **选用两小造新树**   
4. 根据结点个数，申请每个结点对应编码的数组空间    
5. 通过for循环i从[1, n]循环叶子结点，进行以下2步：
6. 从叶子到根求编码，编码填写的位置从后面往前填写，得到该叶子的编码       
7. 将编码存储到HC的数组中   

>译码步骤：    
1. 根据编码，从根结点开始，依次先前循环，直到叶子结点停止      

---

## 4 图    
### 4.1 图的基本概念     
- 图是一种非线性结构     
- 图的特点：顶点之间关系任意的、图中任意两个顶点之间都有可能相、顶点的前驱和后继个数无限制      
- 图的应用领域：语言学、逻辑学、物理、化学、数学、计算机科学     
#### 4.1.1 图的定义   
图是一种数据元素间存在多对多关系的数据结构加上一组基本操作构成的抽象数据结构。      
图是一种复杂的非线性数据结构，由顶点集合及顶点间关系集合组成。可表示为：`G = (V, VR)`   
其中V是顶点的有穷非空集合；VR是顶点之间关系的有穷集合，也叫作弧或边集合。弧是顶点的有序对，边是顶点的无序对。    
#### 4.1.2 图的基本术语   
顶点：图中的数据元素    
弧：若 <v, w>∈VR，则 <v, w> 表示从 v 到 w 的一条弧，且称 v 为弧尾，称 w 为弧头，此时的图称为有向图。  
边：若 <v, w>∈VR 必有<w, v>∈VR，则以 无序对 (v, w) 代表这两个有序对，表示 v 和 w 之间的一条边，此时的图称为无向图。    
无向图中边的取值范围：`0≤e≤n(n-1)/2`    
完全图：有n(n-1)/2条边的无向图，成为**完全图**   
有向图中弧的取值范围：`0≤e≤n(n-1)`    
有向完全图：有 n (n - 1) 条弧的有向图（即：每两个顶点之间都存在着方向相反的两条弧）称为有向完全图。    
稀疏图：含有很少条边或弧的图    
稠密图：含有很多条边或弧的接近完全图的图      
权：与图中边或弧相关的数，这些数可以表示从一个顶点到另一个顶点的距离或耗费     
网：带权的图    
子图：如果图 G = (V, E) 和 G´= (V ´, E´)，满足：V ´ V 且 E´ E，则称 G´为G 的子图。   
邻接点：若 (v, v´) 是一条边，则称顶点 v 和 v´互为 邻接点，或称 v 和 v´相邻接；称边 (v, v´) 依附于顶点 v 和 v´，或称 (v, v´) 与顶点 v 和 v´ 相关联。    
若 <v, v´> 是一条弧，则称顶点 v 邻接到 v´，顶点v´邻接自顶点 v。并称弧 <v, v´> 与顶点 v 和 v´ 相关联。    
度：无向图中顶点v的度是和v相关联的边的数目，记作：TD(v)   
入度：有向图中以顶点 v 为头的弧的数目称为 v 的入度， 记为：ID(v)。    
出度：有向图中以顶点 v 为尾的弧的数目称为 v 的出度， 记为：OD(v)。    
度：入度和出度之和，即：TD(v) = ID(v) + OD(v)。    
如果顶点 vi 的度为 TD(vi)，则一个有 n 个顶点 e 条 边（弧）的图，满足如下关系：    
$$  e = \frac{1}{2} \sum_{i=1}^{n}TD(v_i)  $$     
路径：从顶点 v 到 v´ 的路径是一个顶点序列   
路径长度：路径上边或弧的数目。     
回路（环）：第一个顶点和最后一个顶点相同的路径。    
简单路径：序列中顶点（两端点除外）不重复出现的路径。     
简单回路（简单环）：前后两端点相同的简单路径。    
连通：从顶点 v 到 v´ 有路径，则说 v  和 v´ 是连通的。     
连通图：图中任意两个顶点都是连通的。    
非连通图：有 n 个顶点和小于 n-1 条边的图。    
连通分量：无向图的极大连通子图（不存在包含它的更大的连通子图）；任何连通图的连通分量只有一个，即其本身；非连通图有多个连通分量（非连通图的每一个连通部分）。     
强连通图： 任意两个顶点都连通的有向图。    
强连通分量：有向图的极大强连通子图；任何强连通图的强连通分量只有一个，即其本身；非强连通图有多个强连通分量。    
生成树：所有顶点均由边连接在一起但不存在回路的图。     
一个图可以有许多棵不同的生成树。     
所有生成树具有以下共同特点：  
- 生成树的顶点个数与图的顶点个数相同；   
- 生成树是图的极小连通子图；   
- 一个有 n 个顶点的连通图的生成树有 n-1 条边；   
- 生成树中任意两个顶点间的路径是唯一的；   
- 在生成树中再加一条边必然形成回路。   
- 含 n 个顶点 n-1 条边的图不一定是生成树。     

生成森林：对于非连通图，其每个连通分量可以构造一棵生成树，合成起来就是一个生成森林。  
有向树：如果一个有向图恰有一个顶点的入度为 0 ，其余顶点的入度均为 1 ，则是一棵有向树。  
有向图的生成森林：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。   

### 4.2 图的存储结构   
### 4.2.1 数组表示法    
[MGraph-静态-顺序-引用](../05_data-structure-code/7-图/01-Algorithm-mgraph-(静态-顺序-引用).cpp)      
[MGraph-静态-顺序-指针](../05_data-structure-code/7-图/02-Algorithm-mgraph-(静态-顺序-指针).c)      

一个有 n 个顶点的图，可用两个数组存储。其中一个一维数组存储数据元素（顶点）的信息，另一个二维数组（邻接矩阵）存储数据元素之间的关系（边或弧）的信息。    
>特点：  
1. 无向图的邻接矩阵对称，可压缩存储；有 n 个顶点的无向图所需存储空间为 n(n-1)/2。   
2. 有向图的邻接矩阵不一定对称；有 n 个顶点的有向图所需存储空间为 n²，用于稀疏图时空间浪费严重。  
3. 无向图中顶点 vi 的度 TD(vi) 是邻接矩阵中第 i 行 1 的个数。    
4. 有向图中顶点 vi 的出度是邻接矩阵中第 i 行 1 的个数。  
5. 有向图中顶点 vi 的入度是邻接矩阵中第 i 列 1 的个数。  

### 4.2.2 邻接表    
[ALGraph-静态-顺序-引用](../05_data-structure-code/7-图/03-Algorithm-algraph-(动态-顺序-链式-引用).cpp)      
[ALGraph-静态-顺序-指针](../05_data-structure-code/7-图/04-Algorithm-algraph-(动态-顺序-链式-指针).c)   
>特点：   
1. 若无向图中有 n 个顶点、e 条边，则其邻接表需 n 个头结点和 2e 个表结点。适宜存储稀疏图。   
2. 无向图中顶点 vi 的度为第 i 个单链表中的结点数。   
3. 对于有向图，找出度容易，找入度难   

---

## 5 课下作业        
1. 雪梨作业任务7   
2. 把第6章的PPT后面习题做一下       
3. 把Huffman编码和译码实现一下    
4. 压缩和解压缩也实现一下   

---












