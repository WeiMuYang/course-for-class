# 09-2 上课计划     
---
## 1 回忆上节课内容  
### 1.1 杂事  
1. QQ群里有个第5次发到QQ邮箱的任务，8个函数，《05-DS作业-串的堆分配-指针-10-29》   
2. 截止时间2019-11-03      
3. 复习时，把握重点，咱们每次都给大家总结了重点内容，自己看看     
4. 本次小测占据10分    
5. 考试范围到我们今天讲的模式匹配（也有可能不考这一块）  
6. 线性表的几种结构好好看看     
7. 雪梨发布第5次任务，提前做，有点难度    

### 1.2 上节课总结    
[Class09-1](../course-summary/Class09-1-20191029.txt)      
```
## 09-1-20191029                
1. 串的堆分配存储基本操作——串插入            （掌握、实现）        
2. 串的堆分配存储基本操作——串联接、求子串     （理解）     
3. 串的堆分配存储基本操作——串赋值            （掌握、实现）    
4. 串的堆分配存储基本操作——串比较、串清空     （了解）     
5. 串的块链存储结构及优缺点                 （理解）     
6. 串的朴素模式匹配                        （理解）      
```
### 1.3 学生的问题        
1. 对于串的理解不够深入，一直沉浸在C语言中的串里面     
2. 编程能力太差，对于串的操作编程出问题了    

---




## 2 串       
> [静态-顺序-引用（定长顺序存储）](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/01-Algorithm-string-(静态-顺序-引用).cpp)       
> [静态-顺序-指针（定长顺序存储）](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/02-Algorithm-string-(静态-顺序-指针).c)       
> [动态-顺序-引用（堆分配存储）](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/03-Algorithm-string-(动态-顺序-引用).cpp)      
> [动态-顺序-指针（堆分配存储）](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/04-Algorithm-string-(动态-顺序-指针).c)      
> [动态-链式-引用（块链存储）](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/05-Algorithm-string-(动态-链式-引用).cpp)             

### 2.1 串的模式匹配      
**模式匹配** ：子串定位运算。    
**串匹配**就是在主串中找出子串出现的位置。          

#### 2.1.1 朴素的模式匹配算法      
> [算法4.5-引用](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/14-Algorithm-4.5-(静态-顺序-引用).cpp)            
> [算法4.5-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/15-Algorithm-4.5-(静态-顺序-指针).c)              
- `int Index(SString S, SString T,int pos)`      

>算法思想：从主串 S 的第 pos 个字符起和模式 T 的第一个字符比较之，若相同，则继续比较后续字符；否则从主串 S的下一个字符起再重新和模式 T 的字符比较之。        

>算法步骤：
1. 主串从第`pos`个位置开始，子串从第`1`个位置开始            
2. `while`循环只要主串S和子串T不为空，循环下面一步：    
3. 若`S[i]`和`T[j]`对应相等，两个指针分别向后移动，否则，回退`j-1`(j从1增加到j，走了j-1步)，i再向后移动一位，`j`从`1`开始          
4. 循环结束，判断`j>T[0]`是否成立，若成立，返回`i - T[0]`    

>算法评价：      
>1. 通常情况下，效率比较高，经常被程序员选用。 此时算法的时间复杂度为：$ O(n+m) $      
>2. 某些特殊的情况下，效率比较低。 此时算法的时间复杂度为：$ O(n \times m) $         
>3. 以书上P79页的例子进行讲解，若最极端情况：$ （主串字符个数n - 模式串字符个数m+1）\times 模式串长m $ :        
>> 1. 将主串放在第0行，模式串从第1行开始，每回溯一次换一行；   
>> 2. 在匹配过程中，每多一行，就多匹配模式串长次；   
>> 3. 一共有：主串字符个数n - 模式串字符个数m + 1  行；   
>> 4. 回溯的行数，是：(n - m + 1) -1 = n-m，因为最后一次匹配成功，不算回溯的;    
>> 5. 时间复杂度：频度
$$
(n-m+1)  \times n ;  \because n > m  &there4  O(n \times m)
$$


#### 2.1.2 KMP算法       
> [算法4.6-4.7-引用](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/16-Algorithm-4.6-4.7(静态-顺序-引用).cpp)            
> [算法4.5-指针](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/17-Algorithm-4.6-4.7(静态-顺序-指针).c)              
- `int Index_KMP(SString S, SString T,int pos)`      
- 当子串和主串失配后，主串`i`保持不动，子串`j`滑动到`next[j]` 的位置    
- 子串的next数组中，下标`i`对应的值，就是串中第`i`s个字符要滑动的位置        
- next数组中，下标和字符位置对应，因此，next[0]不用，从next[1]开始用    
- next[1] = 0，因为第一次失配的话，j还要变成1，而i需要向后移动，因此，需要自增，因此next[1] = 0    
- next函数值仅取决于模式串本身，而与主串无关。    

>KMP算法步骤：    
1. 主串从第`pos`个位置开始，子串从第`1`个位置开始            
2. `while`循环只要主串S和子串T不为空，循环下面一步：    
3. 若`S[i]`和`T[j]`对应相等，两个指针分别向后移动，否则，`i`不变，`j = next[j]`   
4. 循环结束，判断`j>T[0]`是否成立，若成立，返回`i - T[0]`      


>get_next函数：next[1] = 0， next[2] = 1，不会变化     

>get_next函数思路：     
>1. i作为next数组的下标，j作为next数组中上一次的值      
>2. 初态，i从1开始，next数组0号空间不用；next[1] = 0 ；j作为上一次的值，因此j取值0
>3. 通过while循环依次向next数组中赋值     
>>1. 若j回退到0，或者第i个字符和第next[i]个字符相等，那么，next[i+1] = j+1;
>>2. 否则的话：j回退到next[j]的位置，继续循环直至： j回退到0，或者第i个字符和第next[i]个字符相等  


>get_next数组步骤：   
1. next[1] = 0，i = 1，j = 0    
2. while循环给next数组赋值     
3. 若j == 0 || T[i] == T[j] ：自增i，自增j， 将next[i] = j;    
4. 否则 j = next[j];      

>next数组手动求法：
>1. 先将next[1] = 0, next[2] = 1，下标是1和2的解决了   
>2. 当i>2时，next[i] = 第i-1个字符 == 第next[i-1]个字符 ？ next[i-1] + 1 ：进入3步    
>3. next[i] =  第i-1个字符 == 第next[next[i-1]]个字符 ？ next[next[i-1]] + 1 : 进入第4步   
>4. next[i] =  第i-1个字符 == 第next[next[next[i-1]]]个字符 ？next[ next[next[i-1]]]+ 1 : 进入第5步   
>5. .......     
>6. 直到next[next[next[i-1]]...] == 0; 则next[i] = 1 。      


#### 2.1.3 改进后next数组      
>[get_nextval函数](../../../../GithubRepository/WeiMuYang/data-structure/数据结构代码/4-串/18-Algorithm-4.6-4.8(静态-顺序-引用).cpp)        

>nextval数组手动求法：
>1. 先求出next数组       
>2. 第i个字符和第next[i]个字符是否相等：    
>>-  若相等，则nextval[i] = nextval[next[i]]     
>>- 若不等，则nextval[i] = next[i]       



## 3 课下作业        
1. 抓紧时间复习准备数据结构小测      
2. 群里面的第5次邮箱任务——《05-DS作业-串的堆分配-指针-10-29》    

---












