# 13-2 上课计划     

---

## 1 回忆上节课内容  
### 1.1 杂事  
1. 补课一次，讲一下去年小测试题    
4. 课下大家多做题，下周第二次小测     
5. 第二次小测押题卷（自己准备就行）    


### 1.2 上节课总结    
[Class13-1](../course-summary/Class13-1-20191126.txt)      
```
## 13-1-20191126                             
1. 哈夫曼树的基本概念           （理解）      
2. 哈夫曼树的构造              （理解、掌握、实现）      
3. 哈夫曼编码与译码             （理解、掌握、实现）       
4. 图的定义及术语               （理解）      
```

---


## 2 图    
### 2.1 图的基本概念
顶点：图中的数据元素    
弧：若 <v, w>∈VR，则 <v, w> 表示从 v 到 w 的一条弧，且称 v 为弧尾，称 w 为弧头，此时的图称为有向图。  
边：若 <v, w>∈VR 必有<w, v>∈VR，则以 无序对 (v, w) 代表这两个有序对，表示 v 和 w 之间的一条边，此时的图称为无向图。    
无向图中边的取值范围：`0≤e≤n(n-1)/2`    
完全图：有n(n-1)/2条边的无向图，成为**完全图**   
有向图中弧的取值范围：`0≤e≤n(n-1)`    
有向完全图：有 n (n - 1) 条弧的有向图（即：每两个顶点之间都存在着方向相反的两条弧）称为有向完全图。    
稀疏图：含有很少条边或弧的图    
稠密图：含有很多条边或弧的接近完全图的图      
权：与图中边或弧相关的数，这些数可以表示从一个顶点到另一个顶点的距离或耗费     
网：带权的图    
子图：如果图 G = (V, E) 和 G´= (V ´, E´)，满足：V ´ V 且 E´ E，则称 G´为G 的子图。   
邻接点：若 (v, v´) 是一条边，则称顶点 v 和 v´互为 邻接点，或称 v 和 v´相邻接；称边 (v, v´) 依附于顶点 v 和 v´，或称 (v, v´) 与顶点 v 和 v´ 相关联。    
若 <v, v´> 是一条弧，则称顶点 v 邻接到 v´，顶点v´邻接自顶点 v。并称弧 <v, v´> 与顶点 v 和 v´ 相关联。    
度：无向图中顶点v的度是和v相关联的边的数目，记作：TD(v)   
入度：有向图中以顶点 v 为头的弧的数目称为 v 的入度， 记为：ID(v)。    
出度：有向图中以顶点 v 为尾的弧的数目称为 v 的出度， 记为：OD(v)。    
度：入度和出度之和，即：TD(v) = ID(v) + OD(v)。    
如果顶点 vi 的度为 TD(vi)，则一个有 n 个顶点 e 条 边（弧）的图，满足如下关系：    
$$  e = \frac{1}{2} \sum_{i=1}^{n}TD(v_i)  $$     
路径：从顶点 v 到 v´ 的路径是一个顶点序列   
路径长度：路径上边或弧的数目。     
回路（环）：第一个顶点和最后一个顶点相同的路径。    
简单路径：序列中顶点（两端点除外）不重复出现的路径。     
简单回路（简单环）：前后两端点相同的简单路径。    
连通：从顶点 v 到 v´ 有路径，则说 v  和 v´ 是连通的。     
连通图：图中任意两个顶点都是连通的。    
非连通图：有 n 个顶点和小于 n-1 条边的图。    
连通分量：无向图的极大连通子图（不存在包含它的更大的连通子图）；任何连通图的连通分量只有一个，即其本身；非连通图有多个连通分量（非连通图的每一个连通部分）。     
强连通图： 任意两个顶点都连通的有向图。    
强连通分量：有向图的极大强连通子图；任何强连通图的强连通分量只有一个，即其本身；非强连通图有多个强连通分量。    
生成树：所有顶点均由边连接在一起但不存在回路的图。     
一个图可以有许多棵不同的生成树。     
所有生成树具有以下共同特点：  
- 生成树的顶点个数与图的顶点个数相同；   
- 生成树是图的极小连通子图；   
- 一个有 n 个顶点的连通图的生成树有 n-1 条边；   
- 生成树中任意两个顶点间的路径是唯一的；   
- 在生成树中再加一条边必然形成回路。   
- 含 n 个顶点 n-1 条边的图不一定是生成树。     

生成森林：对于非连通图，其每个连通分量可以构造一棵生成树，合成起来就是一个生成森林。  
有向树：如果一个有向图恰有一个顶点的入度为 0 ，其余顶点的入度均为 1 ，则是一棵有向树。  
有向图的生成森林：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。   

### 2.2 图的存储结构   
### 2.2.1 数组表示法    
[MGraph-静态-顺序-引用](../../05_data-structure-code/7-图/01-Algorithm-mgraph-(静态-顺序-引用).cpp)      
[MGraph-静态-顺序-指针](../../05_data-structure-code/7-图/02-Algorithm-mgraph-(静态-顺序-指针).c)      

一个有 n 个顶点的图，可用两个数组存储。其中一个一维数组存储数据元素（顶点）的信息，另一个二维数组（邻接矩阵）存储数据元素之间的关系（边或弧）的信息。    
>特点：  
1. 无向图的邻接矩阵对称，可压缩存储；有 n 个顶点的无向图所需存储空间为 n(n-1)/2。   
2. 有向图的邻接矩阵不一定对称；有 n 个顶点的有向图所需存储空间为 n²，用于稀疏图时空间浪费严重。  
3. 无向图中顶点 vi 的度 TD(vi) 是邻接矩阵中第 i 行 1 的个数。    
4. 有向图中顶点 vi 的出度是邻接矩阵中第 i 行 1 的个数。  
5. 有向图中顶点 vi 的入度是邻接矩阵中第 i 列 1 的个数。  

>图的数组表示法存储结构    
```C
#define	INFINITY INT_MAX	//整型的最大值∞
//实际上 INT_MAX == 2147483647 maximum (signed) int value 
#define MAX_VERTEX_NUM 20	//最大顶点个数

#define VRType int			//顶点关系类型
#define InfoType int		//弧相关信息类型
#define VertexType char		//顶点向量类型
typedef enum
{
    DG,DN,UDG,UDN			//有向图，有向网，无向图，无向网
}GraphKind;					

typedef struct 
{
    VRType adj;		//VRType是顶点关系类型。对无权图，用1或0表示是否邻接；
    //对有权图，则为权值类型。
    InfoType *info;	//该弧相关信息的指针
} ARCCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

typedef struct
{
    VertexType vexs[MAX_VERTEX_NUM];
    //顶点向量{’1','2','3'...}用来标记矩阵的行列代表那个顶点
    AdjMatrix arcs;					//邻接矩阵
    int vexnum, arcnum;				//图的当前顶点数和弧数
    GraphKind kind;					//图的种类标志
}MGraph;
```

### 2.2.2 邻接表    
[ALGraph-静态-顺序-引用](../../05_data-structure-code/7-图/03-Algorithm-algraph-(动态-顺序-链式-引用).cpp)      
[ALGraph-静态-顺序-指针](../../05_data-structure-code/7-图/04-Algorithm-algraph-(动态-顺序-链式-指针).c)   
>特点：   
1. 若无向图中有 n 个顶点、e 条边，则其邻接表需 n 个头结点和 2e 个表结点。适宜存储稀疏图。   
2. 无向图中顶点 vi 的度为第 i 个单链表中的结点数。   
3. 对于有向图，找出度容易，找入度难   


>图的邻接表表示法存储结构    
```C
#define MAX_VERTEX_NUM  20
#define InfoType        int	//该弧相关信息的指针（假设信息是整数，因此用int类型）
#define VertexType      char	//顶点类型（假设每个顶点是一个字符表示）

typedef enum {
    DG,DN,UDG,UDN			//有向图，有向网，无向图，无向网
}GraphKind;		

typedef struct ArcNode {    //表结点类型
    int adjvex;				//该弧指向顶点位置 0,1,2,3...
    //这个位置指的是邻接的顶点在表头数组中的位置
    struct ArcNode * nextarc;	//指向下一条弧的指针
    InfoType *info;				//该弧相关信息的指针
}ArcNode;

typedef struct VNode {  //头结点类型
    VertexType data;	//顶点信息（VertexType实际上是顶点类型）
    ArcNode *firstarc;	//指向第一条依附该顶点的弧的指针
}VNode, AdjList[MAX_VERTEX_NUM];

typedef struct	{	    //邻接表类型
    AdjList vertices;	
    int vexnum;	//图的顶点数
    int arcnum;	//图的弧数
    GraphKind kind;			//图的类型标志
}ALGraph;
```

### 2.2.3 十字链表     
```C
//---有向图的十字链表存储表示---
typedef struct ArcBox {	//弧结点的结构
	int tailvex, headvex;		//该弧的尾和头顶点的位置
	struct ArcBox *hlink,*tlink;//分别为弧头相同和弧尾相同的弧的链域
	InfoType *info;				//该弧相关信息的指针
}ArcBox;

typedef struct VexNode {	//顶点结点结构
	VertexType data;			//顶点信息（VertexType实际上是顶点类型）
	ArcBox *firstin, *firstout;	//分别指向该顶点第一条入弧和出弧
}VexNode;

typedef struct	{		//十字链表结构
	VexNode xlist[MAX_VERTEX_NUM];//表头向量
	int vexnum, arcnum;			  //有向图的当前顶点数和弧数
}OLGraph;
```
>十字链表画法步骤：   
1. 先写出顶点结点，确定图的每一行，写出data域，并标记每行行号0-n-1  
2. 在图的上方标记每列，方便画图，属于草稿，a b c d并分别写上0 1 2 3  
3. 先画以顶点结点为弧尾的弧，然后链接成单链表；    
4. 在画结点时，每个结点所在的位置行列：第几行有弧尾顶点确定，第几列由弧头顶点确定    
5. 循环第3步和第4步，画出所有弧     


### 2.3 图的遍历     

从图的任意指定顶点出发，依照某种规则去访问图中所有顶点，且每个顶点仅被访问一次，这一过程叫做图的遍历。   
图的遍历按照深度优先和广度优先规则去实施，通常有**深度优先遍历法（Depth_First Search——DFS ）**和** 广度优先遍历法（ Breadth_Frist Search——BFS）**两种。   

#### 2.3.1 深度优先遍历（DFS）    
>步骤：    
1. 访问指定的起始顶点；   
2、若当前访问的顶点的邻接顶点有未被访问的，则任选 一个访问之，转2；反之，退回到最近访问过的顶点；直到与起始顶点相通的全部顶点都访问完毕；    
3、若此时图中尚有顶点未被访问，则再选其中一个顶点作为起始顶点并访问之，转 2； 反之，遍历结束。    

连通图的深度优先遍历类似于树的先根遍历    


#### 2.3.2 广度优先遍历（BFS）    
>步骤：   
方法：从图的某一结点出发，首先依次访问该结点的所有邻接顶点 Vi1, Vi2, …, Vin 再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止。    



### 2.4 最小生成树    
最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权数之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。   
**MST 性质**：设 N = (V, E)  是一个连通网，U 是顶点集 V的一个非空子集。若边 (u, v) 是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边 (u, v) 的最小生成树。   

>普里姆 (Prim) 算法:    
1. 设 N=(V, E) 是连通网，TE 是N 上最小生成树中边的集合。    
2. 初始令 U={u0}, (u0V ), TE={ }。    
3. 在所有 uU, vV-U 的边 (u, v)E 中，找一条代价最小的边 (u0, v0)。    
4. 将 (u0, v0) 并入集合 TE，同时 v0 并入 U。    
5. 重复上述操作直至 U=V 为止，则 T=(V, TE) 为 N 的最小生成树。  


>克鲁斯卡尔 (Kruskal) 算法:   
1. 设连通网  N = (V, E )，令最小生成树初状态为只有 n 个顶点而无边的非连通图 T=(V, { })，每个顶点自成一个连通分量。   
2. 在 E 中选取代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上（即：不能形成环），则将此边加入到 T 中；否则，舍去此边，选取下一条代价最小的边。   
3. 依此类推，直至 T 中所有顶点都在同一连通分量上为止。   

最小生成树 可能不惟一   

### 2.5 有向无环图及其应用   
有向无环图：无环的有向图，简称 DAG (Directed Acycline Graph) 图。   
### 2.6 拓扑排序     
用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV (Activity On  Vertex network)网。   

>AOV 网的特点：   
- 若从 i 到 j 有一条有向路径，则 i 是 j 的前驱；j 是 i 的后继。   
- 若 < i , j > 是网中有向边，则 i 是  j 的直接前驱； j 是 i 的直接后继。  
- AOV 网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。   

**拓扑排序**:若在 AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧 <i,  j> 存在，则在这个序列中， i  一定排在  j 的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。   

>拓扑排序：   
1. 在有向图中选一个没有前驱的顶点且输出之。    
2. 从图中删除该顶点和所有以它为尾的弧。   
3. 重复上述两步，直至全部顶点均已输出；或者当图中存在无前驱的顶点为止。   




---

## 3 课下作业        
1. 雪梨作业任务7   
2. 把第6章的PPT后面习题做一下       
3. 把Huffman编码和译码实现一下    
4. 压缩和解压缩也实现一下   

---












